\documentclass[parskip=half]{scrartcl}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{hyperref}


\title{Empirical Industrial Organization and Market Design}
\subtitle{Computational Assignment}
\author{James Atkins \\ 3081967}
\date{Due 10 January 2020}

\DeclareMathOperator{\E}{\mathbb{E}}
\newcommand{\code}[1]{\texttt{#1}}

\begin{document}
	
\maketitle


\section{Model}


\begin{equation}
u_{ijt} = \delta_{jt} + \mu_{ijt} + \epsilon_{ijt}
\end{equation}

\begin{equation}
\delta_{jt}(x_{jt})
\end{equation}

\(X_1\) is the \(N \times K_1\) matrix of observed demand-side product characteristics.

\(X_2\) is the \(N \times K_2\) matrix of nonlinear characteristics. 

Observed demand-side product characteristics are contained in the 


In market \(t\)



It is common to assume that \(f(\beta_i|\theta)\) follows a multivariate normal distribution, and to break it up into three parts:

\begin{enumerate}
\item A mean \(K_1 \times 1\) taste which all individuals agree on, \(\beta\).
\item A \(K_2 \times K_2\) covariance matrix, \(\Sigma\).
\item Any \(K_2 \times D\) interactions, with observed \(D \times 1\) demographic data, \(d_i\)
\end{enumerate}

\begin{equation}
\beta_i \sim N(\beta + \Pi d_i, \Sigma)
\end{equation}


\section{Notation}

\begin{tabular}{l l}
	\(j\) & Products \\
	\(t\) & Markets \\
	\(i\) & Individuals \\
	\\
	\(N\) & Number of products across all markets \\
	\(T\) & Number of markets \\
	\(J_t\) & Number of products in market \(t\) \\
	\(I_t\) & Number of individuals in market \(t\) \\
	\\
	\(\boldsymbol{x}_{jt} = (x^1_{jt}, \dotsc, x^k_{jt})\) & Observed product characteristics for product \(j\) in market \(t\). \\
	\\
	\(p_{jt}\) & Price of \(j\) in market \(t\) \\
	$\mathcal{S}_{jt}$ & Observed market share of \(j\) in market \(t\)
	
\end{tabular}

\section{miniblp}

\code{miniblp}

\subsection{Parallelism}

The market inversion can be computed for each market independently

\subsection{numba}

Numba\footnote{\url{http://numba.pydata.org/}} is ``an open source JIT compiler that translates a subset of Python and NumPy code into fast machine code''. Numba-compiled numerical algorithms can approach the speeds of C.

\subsection{log-sum-exp trick}

\url{https://blog.feedly.com/tricks-of-the-trade-logsumexp/}

Safeguards against numerical overflow

\begin{equation}
LSE(x_1, \dots, x_K) = \log \sum_k \exp x_k = a + \log \sum_k \exp (x_k - a)
\end{equation}

where \(a = \max_k x_k\)

\section{BLP Algorithm}

For each guess of \(\theta_2\):

\begin{enumerate}

\item For each market \(t\), solve \(s_{\cdot t}(\delta_{\cdot t}, \boldsymbol{x}_{\cdot t}, p_{\cdot t}; \theta_2) = \mathcal{S}_{\cdot t}\) for \(\delta_{\cdot t}\) by inversion,


\begin{equation}
\hat\delta_{\cdot t}( \mathcal{S}_{\cdot t}, \theta_2) = s^{-1}_{\cdot t}(\mathcal{S}_{.t}, \boldsymbol{x}_{.t}, p_{.t}; \theta_2)
\end{equation}

This step is embarrassingly parallel as \(\hat\delta_{\cdot t}( \mathcal{S}_{\cdot t}, \theta_2)\) can be computed for each market independently.

\item Stack up \(\hat\delta_{\cdot t}( \mathcal{S}_{\cdot t}, \theta_2)\) across all markets, estimate \(\theta_1\) by ``concentrating out'' the linear parameters, and compute the error term \(\omega\),

\begin{gather}
\hat{\theta}_1(\theta_2) = (X_1'ZWZ'X_1)^{-1}X_1'ZWZ'\hat{\delta}(\theta_2) \\
\omega(\theta_2) = \hat{\delta}(\theta_2) - X_1 \hat{\theta}_1(\theta_2)
\end{gather}

\item Construct the GMM objective function,

\begin{equation}
\omega(\theta_2)' Z W Z' \omega(\theta_2)
\end{equation}

\end{enumerate}


A non-linear optimiser then searchs for the value of \(\theta_2\) that minimises the GMM objective function. The optimiser can be aided by computing the analytic gradient.

Aymptotically efficient estimates can be achieved using two-step GMM. First, \(\hat{\theta}_2\) is estimated consistently (but not efficiently) with the weighting matrix \(W = (Z'Z/N)^{-1}\). Then a new weighting matrix \(W = \E[Z'\omega(\hat{\theta}_2)\omega(\hat{\theta}_2)'Z]\) is calculated and the computation is re-run.




\end{document}